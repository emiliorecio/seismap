/*
 * File: viewport.js
 * Date: Mon Apr 11 2011 19:01:06 GMT-0300 (Argentina Standard Time)
 *
 * This file was generated by Ext Designer version 1.1.2.
 * http://www.sencha.com/products/designer/
 *
 * This file will be generated the first time you export.
 *
 * You should implement event handling and custom methods in this
 * class.
 */
new DateUnitsStore({
  data : seismap.constants.dateUnits
});
new MagnitudeTypeStore({
  data : seismap.constants.magnitudeTypes
});
new StyleStore({
  data : seismap.constants.styles
});
new EventStore();
new LocationEventStore({
  data : []
});
new EventMagnitudeStore({
  data : []
});
seismap.init = function() {
  var locationEventStore = Ext.StoreMgr.get('locationEventStore');
  var magnitudeField = locationEventStore.fields.get('magnitude');
  magnitudeField.useNull = true;
  magnitudeField.sortType = Ext.data.SortTypes.asNullableFloat;
  var rankMagnitudeField = locationEventStore.fields.get('rankmagnitude');
  rankMagnitudeField.useNull = true;
  rankMagnitudeField.sortType = Ext.data.SortTypes.asNullableFloat;
  return true;
}();

SeismapViewport = Ext.extend(SeismapViewportUi, {
  initComponent : function() {
    SeismapViewport.superclass.initComponent.call(this);

    this.on('afterrender', function(viewport) {
      seismap.ui.initUi();
    });
  }
});

seismap.ui = {};
seismap.ui.clone = function(o) {
  if(!o || 'object' !== typeof o) {
      return o;
  }
  if('function' === typeof o.clone) {
      return o.clone();
  }
  var c = '[object Array]' === Object.prototype.toString.call(o) ? [] : {};
  var p, v;
  for(p in o) {
      if(o.hasOwnProperty(p)) {
          v = o[p];
          if(v && 'object' === typeof v) {
              c[p] = seismap.ui.clone(v);
          }
          else {
              c[p] = v;
          }
      }
  }
  return c;
};
seismap.ui.initUi = function(viewport) {
  function initRadioCompositeFields() {
    // Make radio related elements to check the corresponding radio on
    // click/focus
    Ext.select('.seismap-radio-composite-field').each(function(element) {
      var id = element.id;
      var component = Ext.getCmp(id);
      var radio = component.findByType(Ext.form.Radio)[0];
      function radioSelector(e) {
        if (!radio.disabled && !radio.getValue()) {
          radio.setValue(true);
        }
      }
      var fields = component.findByType(Ext.form.Field);
      for ( var i = 0; i < fields.length; i++) {
        var field = fields[i];
        if (field != radio) {
          if (field.getXType() == 'displayfield') {
            field.getEl().on('click', radioSelector);
          } else {
            field.on('focus', radioSelector);
          }
        }
      }
    });
  }
  function initAnimationPanel() {
    // Make selection of animation "by" to enable/disable the animation
    // configuration
    var fields = [];
    Ext.select('.seismap-animation-field').each(function(element) {
      var id = element.id;
      var component = Ext.getCmp(id);
      fields.push(component);
    });
    var animationKeepModePreviousCompositeField = Ext
        .getCmp('animationKeepModePreviousCompositeField');
    Ext.getCmp('animationByNoneRadio').on('check', function(radio, checked) {
      for ( var i = 0; i < fields.length; i++) {
        var field = fields[i];
        if (checked) {
          field.disable();
        } else {
          field.enable();
        }
      }
    });
  }
  this.legendWindow = Ext.WindowMgr.get('legendWindow');
  initRadioCompositeFields();
  initAnimationPanel();
  this.initMap();
  this.initLocationEventsWindow();
  this.initEventWindow();
  this.initDepthWindow();
  this.registerControlHandles();
  this.initParameters();
};
seismap.ui.initLocationEventsWindow = function() {
  var self = this;
  var locationEventsWindow = Ext.WindowMgr.get('locationEventsWindow');
  // This fixes an ExtJs problem with the window not showing if started as
  // hidden
  locationEventsWindow.getEl().setStyle('visibility', 'visible');
  var closeButton = Ext.getCmp('locationEventsCloseButton');
  var detailsButton = Ext.getCmp('locationEventsDetailsButton');
  var grid = Ext.getCmp('locationEventsGrid');

  var eventWindow = Ext.WindowMgr.get('eventWindow');

  grid.getSelectionModel().on('rowselect', function() {
    detailsButton.enable();
  });
  grid.getSelectionModel().on('rowdeselect', function() {
    detailsButton.disable();
  });
  locationEventsWindow.on('hide', function() {
    detailsButton.disable();
  });
  closeButton.on('click', function() {
    locationEventsWindow.hide();
  });
  detailsButton.on('click', function() {
    var record = grid.getSelectionModel().getSelected();
    var eventId = record.get('id');
    var eventInformation = record.get('information');
    self.showEventWindow(eventId, eventInformation);
  });

};
seismap.ui.initEventWindow = function() {
  var self = this;
  var eventWindow = Ext.WindowMgr.get('eventWindow');
  // This fixes an ExtJs problem with the window not showing if started as
  // hidden.
  eventWindow.getEl().setStyle('visibility', 'visible');
  // End of fix.
  
  var closeButton = Ext.getCmp('eventCloseButton');
  var eventSaveButton = Ext.getCmp('eventSaveButton');
  var eventPanel = Ext.getCmp('eventPanel');
  
  var nameControl = Ext.getCmp('eventNameField');
  var referenceControl = Ext.getCmp('eventReferenceField');
  var notesControl = Ext.getCmp('eventNotesArea');
  var perceivedDistanceControl = Ext.getCmp('eventPerceivedDistanceField');
  var damagedDistanceControl = Ext.getCmp('eventDamagedDistanceField');
  
  if (!seismap.constants.user.administrator) {
    eventSaveButton.hide();
    nameControl.setReadOnly(true);
    referenceControl.setReadOnly(true);
    notesControl.setReadOnly(true);
    perceivedDistanceControl.setReadOnly(true);
    damagedDistanceControl.setReadOnly(true);
  }

  closeButton.on('click', function() {
    eventWindow.hide();
  });
  

  var allFields = eventPanel.findByType(Ext.form.Field);
  eventSaveButton.on('click', function() {
    var errors = false;
    Ext.each(allFields, function(field) {
      errors = errors || !field.isValid();
    });
    if (errors) {
      Ext.Msg.alert('Guardar', 'Por favor, corrija primero los errores.');
      return;
    }
    var eventData = {};
    eventData.name = nameControl.getValue();
    eventData.reference = referenceControl.getValue();
    eventData.notes = notesControl.getValue();
    eventData.perceivedDistance = perceivedDistanceControl.getValue() == '' ? null : perceivedDistanceControl.getValue() * 1000;
    eventData.damagedDistance = damagedDistanceControl.getValue() == '' ? null : damagedDistanceControl.getValue() * 1000;
    
    var request = {
      eventId: self.eventData.id,
      event: eventData
    };
    Ext.Ajax.request({
      url: seismap.constants.baseUri + '/action/event/modify',
      method: 'POST',
      jsonData: request,
      success: function(response, opts) {
        var response = Ext.decode(response.responseText);
        if(response.exception) {
          Ext.Msg.alert('Guardar', response.exception.message);
        } else {
          var event = response.value;
          event.date = new Date(event.date);
          self.eventData = event;
          var eventInformation = self.buildEventInformation(event.id, event.name, event.reference, event.date, event.notes);
          eventWindow.setTitle('Sismo: ' + eventInformation);
          self.loadEventLayers();
          self.loadLayers();
        }
      },
      failure: function(response, opts) {
        Ext.Msg.alert('Guardar', 'Uy.. hubo un error!');
      }
    });
  });
  
};
seismap.ui.initDepthWindow = function() {
  var self = this;
  var depthWindow = Ext.WindowMgr.get('depthWindow');
  // This fixes an ExtJs problem with the window not showing if started as
  // hidden.
  depthWindow.getEl().setStyle('visibility', 'visible');
  // End of fix.
  
  var closeButton = Ext.getCmp('depthCloseButton');
  var depthMapButton = Ext.getCmp('depthMapButton');
  
  closeButton.on('click', function() {
    depthWindow.hide();
  });
  
  depthWindow.on('hide', function() {
    depthMapButton.toggle(false);
  });
};
seismap.ui.stopDepthSelection = function() {
  var depthMapButton = Ext.getCmp('depthMapButton');
  this.depthPolygonControl.deactivate();
  this.map.removeControl(this.depthPolygonControl);
  this.map.removeLayer(this.depthPolygonLayer);
};
seismap.ui.initEventWindowMap = function() {
  if (this.initEventWindowMap.done) {
    return;
  }
  this.initEventWindowMap.done = true;
  var bounds =  new OpenLayers.Bounds(-180, -90,
      180, 90)
  var options = {
    controls : [],
    maxExtent : bounds,
    numZoomLevels : 22,
    displayProjection : new OpenLayers.Projection('EPSG:4326'),
    units : 'degrees',
    theme : seismap.constants.baseUri
        + "/resources/css/lib/openlayers/theme/default/style.css"
  };
  this.eventMap = new OpenLayers.Map(options);
  this.eventMap.addControl(new OpenLayers.Control.PanZoom({
    position : new OpenLayers.Pixel(2, 15)
  }));
  this.eventMap.addControl(new OpenLayers.Control.Navigation());
  this.eventMap.addControl(new OpenLayers.Control.LayerSwitcher({'div':OpenLayers.Util.getElement('layerswitcher')}));
  this.eventMap.addControl(new OpenLayers.Control.ScaleLine());
  this.registerGetFeaturesControl(this.eventMap, this.getEventFeatures);
  
  var eventMapArea = Ext.getCmp('eventMapArea');
  var self = this;

  var center = new OpenLayers.LonLat(this.mapData.centerLongitude,
      this.mapData.centerLatitude);

  var zoom = seismap.constants.eventMapZoom;
  this.eventMapPanel = new GeoExt.MapPanel({
    renderTo : "eventMapArea",
    stateId : "eventMapArea",
    height : eventMapArea.getSize().height,
    width : eventMapArea.getSize().width,
    center : center,
    zoom : zoom,
    map : this.eventMap
  });
  var gphy = new OpenLayers.Layer.Google("Google Physical", {
    type : google.maps.MapTypeId.TERRAIN,
  });
  var gmap = new OpenLayers.Layer.Google("Google Streets", // the default
  {
    numZoomLevels : 20
  });
  var ghyb = new OpenLayers.Layer.Google("Google Hybrid", {
    type : google.maps.MapTypeId.HYBRID,
    numZoomLevels : 20
  });
  var gsat = new OpenLayers.Layer.Google("Google Satellite", {
    type : google.maps.MapTypeId.SATELLITE,
    numZoomLevels : 22
  });
  this.eventMap.addLayers([ gphy, gmap, ghyb, gsat ]);
  
  center = center.transform(this.eventMap.displayProjection, this.eventMap.getProjectionObject());
  this.eventMap.setCenter(center, zoom);
  var self = this;
  eventMapArea.on('resize', function(eventMapArea) {
    self.eventMapPanel.setSize(eventMapArea.getSize());
  });
};
seismap.ui.initDepthWindowMap = function() {
  if (this.initDepthWindowMap.done) {
    return;
  }
  this.initDepthWindowMap.done = true;
  var bounds =  new OpenLayers.Bounds(-180, -90,
      180, 90)
  var options = {
    controls : [],
    maxExtent : bounds,
    numZoomLevels : 22,
    projection : 'EPSG:4326',
    displayProjection : new OpenLayers.Projection('EPSG:4326'),
    units : 'degrees',
    theme : seismap.constants.baseUri
        + "/resources/css/lib/openlayers/theme/default/style.css"
  };
  this.depthMap = new OpenLayers.Map(options);
  this.depthMap.addControl(new OpenLayers.Control.PanZoom({
    position : new OpenLayers.Pixel(2, 15)
  }));
  this.depthMap.addControl(new OpenLayers.Control.Navigation());
  this.depthMap.addControl(new OpenLayers.Control.ScaleLine());
  this.registerGetFeaturesControl(this.depthMap, this.getFeatures);
  
  var depthMapArea = Ext.getCmp('depthMapArea');
  var self = this;

  this.depthMapPanel = new GeoExt.MapPanel({
    renderTo : "depthMapArea",
    stateId : "depthMapArea",
    height : depthMapArea.getSize().height,
    width : depthMapArea.getSize().width,
    center : new OpenLayers.Geometry.Point({x: 0, y: 0}),
    zoom : 1,
    map : this.depthMap
  });

  var self = this;
  depthMapArea.on('resize', function(depthMapArea) {
    self.depthMapPanel.setSize(depthMapArea.getSize());
  });
};
seismap.ui.getEventFeatures = function(e) {
  Ext.each(e.features, function(feature) {
    alert(feature);
  });
};
seismap.ui.showDepthWindow = function(vector) {
  var polygon = vector.geometry;
  var linearRing = polygon.components[0];
  var vertices = linearRing.getVertices();
  
  var depthWindow = Ext.WindowMgr.get('depthWindow');
  depthWindow.show();
  this.legendWindow.toFront();
  this.initDepthWindowMap();
  this.loadDepthLayers(vertices);
  this.depthMap.setCenter(new OpenLayers.Geometry.Point({x: 0, y: 0}), 1);
};
seismap.ui.showEventWindow = function(eventId, eventInformation) {
  var self = this;
  if (!eventInformation) {
    eventInformation = this.buildEventInformation(eventId);
  }
  var request = {
      eventId: eventId
    };
  var eventWindow = Ext.WindowMgr.get('eventWindow');
  Ext.Ajax.request({
    url: seismap.constants.baseUri + '/action/event/get',
    method: 'POST',
    jsonData: request,
    success: function(response, opts) {
      var response = Ext.decode(response.responseText);
      if(response.exception) {
        Ext.Msg.alert('Sismo: ' + eventInformation, response.exception.message);
      } else {
        var event = response.value;        
        event.date = new Date(event.date);
        self.eventData = event;
        var information = self.buildEventInformation(event.id, 
            event.name, event.reference, event.date, event.notes);
        eventWindow.setTitle('Sismo: ' + information);
        eventWindow.show();
        self.legendWindow.toFront();
        self.initEventWindowMap();
        self.loadEventLayers();
        var center = new OpenLayers.LonLat(event.longitude, event.latitude);
        center = center.transform(self.eventMap.displayProjection, self.eventMap.getProjectionObject());
        self.eventMap.setCenter(center, seismap.constants.eventMapZoom);
        self.initEventParameters();
      }
    },
    failure: function(response, opts) {
      Ext.Msg.alert('Sismo: ' + eventInformation, 'Uy.. hubo un error!');
    }
 });  
};
seismap.ui.loadEventLayers = function() {
  if (this.eventLayer) {
    this.eventMap.removeLayer(this.eventLayer);
    this.eventMap.removeLayer(this.eventAffectedLayer);
  }
  this.eventLayer = this.createLayer(this.eventMap, null, 'id = ' + this.eventData.id, 'Sismo', false, null);
  this.eventAffectedLayer = this.createLayer(this.eventMap, null, 'id = ' + this.eventData.id, 'Area afectada', false, {
    sld : 'seismap_affected-distance', 
    variables: {}
  });
  this.addLayer(this.eventLayer);
  this.addLayer(this.eventAffectedLayer);
};
seismap.ui.loadDepthLayers = function(vertices) {
  if (this.depthLayer) {
    this.depthMap.removeLayer(this.depthLayer);
  }
  var cqlFilter = this.cqlFilters[this.currentFrame];
  cqlFilter = cqlFilter == null ? '' : cqlFilter + ' AND ';
  cqlFilter += 'WITHIN(location, POLYGON((';
  for (var i = 0; i < vertices.length + 1; i++) {
    if (i>0) {
      cqlFilter +=', '
    }
    var vertex = vertices[i % vertices.length]; // Add first vertex also at the
                                                // end
    vertex = vertex.clone().transform(this.map.getProjectionObject(), this.map.displayProjection);
    cqlFilter += vertex.x + ' ' + vertex.y;
  }
  cqlFilter += ')))';
  this.depthLayer = this.createLayer(this.depthMap, 'seismap:eventandaveragemagnitudes_depthlocation', cqlFilter, 'Sismos en profundidad', true, null);
  this.addLayer(this.depthLayer);
};
seismap.ui.registerControlHandles = function() {
  function parseDateTime(dateValue, timeValue) {
    var timeSeparatorIndex = timeValue.indexOf(':');
    var hours = timeValue.substring(0, timeSeparatorIndex);
    var minutes = timeValue.substring(timeSeparatorIndex + 1,
        timeSeparatorIndex + 3);
    var dateTimeValue = new Date(dateValue);
    dateTimeValue.setHours(dateTimeValue.getHours() + hours);
    dateTimeValue.setMinutes(dateTimeValue.getMinutes() + minutes);
    return dateTimeValue;
  }
  var self = this;
  var zoomControl = Ext.getCmp('initialZoomControl');
  var centerLatitudeControl = Ext.getCmp('initialLatitudeControl');
  var centerLongitudeControl = Ext.getCmp('initialLongitudeControl');
  var styleControl = Ext.getCmp('styleCombo');

  var minDateTypeNoneControl = Ext.getCmp('dateMinModeNoneRadio');
  var minDateTypeRelativeControl = Ext.getCmp('dateMinModeRelativeRadio');
  var minDateTypeAbsoluteControl = Ext.getCmp('dateMinModeAbsoluteRadio');
  var minDateRelativeAmountControl = Ext.getCmp('dateMinRelativeAmountField');
  var minDateRelativeUnitsControl = Ext.getCmp('dateMinRelativeUnitsCombo');
  var minDateControl = Ext.getCmp('dateMinAbsoluteDateField');
  var minTimeControl = Ext.getCmp('dateMinAbsoluteTimeField');
  var maxDateTypeNoneControl = Ext.getCmp('dateMaxModeNoneRadio');
  var maxDateTypeRelativeControl = Ext.getCmp('dateMaxModeRelativeRadio');
  var maxDateTypeAbsoluteControl = Ext.getCmp('dateMaxModeAbsoluteRadio');
  var maxDateRelativeAmountControl = Ext.getCmp('dateMaxRelativeAmountField');
  var maxDateRelativeUnitsControl = Ext.getCmp('dateMaxRelativeUnitsCombo');
  var maxDateControl = Ext.getCmp('dateMaxAbsoluteDateField');
  var maxTimeControl = Ext.getCmp('dateMaxAbsoluteTimeField');
  var maxDepthTypeNoneControl = Ext.getCmp('depthMaxModeNoneRadio');
  var maxDepthTypeAbsoluteControl = Ext.getCmp('depthMaxModeAbsoluteRadio');
  var maxDepthControl = Ext.getCmp('depthMaxAbsoluteAmountField');
  var minDepthTypeNoneControl = Ext.getCmp('depthMinModeNoneRadio');
  var minDepthTypeAbsoluteControl = Ext.getCmp('depthMinModeAbsoluteRadio');
  var minDepthControl = Ext.getCmp('depthMinAbsoluteAmountField');
  var magnitudeTypeControl = Ext.getCmp('magnitudeScaleCombo');
  var maxMagnitudeTypeNoneControl = Ext.getCmp('magnitudeMaxModeNoneRadio');
  var maxMagnitudeTypeAbsoluteControl = Ext
      .getCmp('magnitudeMaxModeAbsoluteRadio');
  var maxMagnitudeControl = Ext.getCmp('magnitudeMaxAbsoluteAmountField');
  var minMagnitudeTypeNoneControl = Ext.getCmp('magnitudeMinModeNoneRadio');
  var minMagnitudeTypeAbsoluteControl = Ext
      .getCmp('magnitudeMinModeAbsoluteRadio');
  var minMagnitudeControl = Ext.getCmp('magnitudeMinAbsoluteAmountField');
  var listUnmeasuredControl = Ext
      .getCmp('magnitudeUnmeasuredVisibilityCheckbox');

  var animationTypeNoneControl = Ext.getCmp('animationByNoneRadio');
  var animationTypeDateControl = Ext.getCmp('animationByDateRadio');
  var animationTypeDepthControl = Ext.getCmp('animationByDepthRadio');
  var animationTypeMagnitudeControl = Ext.getCmp('animationByMagnitudeRadio');
  var animationStepsControl = Ext.getCmp('animationStepAmountField');
  var animationStepDurationControl = Ext.getCmp('animationDurationField');
  var animationStepKeepControl = Ext.getCmp('animationKeepPreviousAmountField');
  var reverseAnimationControl = Ext.getCmp('reverseAnimationCheckbox');

  var showInitialViewLink = Ext.getCmp('showInitialViewLink');
  var useCurrentViewLink = Ext.getCmp('useCurrentViewLink');

  useCurrentViewLink.getEl().on('click', function() {
    var center = self.map.getCenter();
    center = center.transform(self.map.getProjectionObject(), self.map.displayProjection);
    zoomControl.setValue(self.map.getZoom());
    centerLatitudeControl.setValue(center.lat);
    centerLongitudeControl.setValue(center.lon);
  });

  showInitialViewLink.getEl().on('click', function() {
    if (!centerLongitudeControl.isValid() || !centerLatitudeControl.isValid()) {
      return;
    }
    var zoom = zoomControl.getValue();
    var center = new OpenLayers.LonLat(centerLongitudeControl.getValue(),
      centerLatitudeControl.getValue());
    center = center.transform(self.map.displayProjection, self.map.getProjectionObject());
    self.map.setCenter(center, zoom);
  });

  var mapViewPanel = Ext.getCmp('mapViewPanel');
  var parametersPanel = Ext.getCmp('parametersPanel');
  var applyButton = Ext.getCmp('applyButton');
  var saveChangesButton = Ext.getCmp('saveChangesButton');
  var discardChangesButton = Ext.getCmp('discardChangesButton');
  var saveMapAsButton = Ext.getCmp('saveMapAsButton');
  var deleteMapButton = Ext.getCmp('deleteMapButton');
  var depthMapButton = Ext.getCmp('depthMapButton');
  
  if (this.mapData.id) {
    saveChangesButton.enable();
    deleteMapButton.enable();
  }

  depthMapButton.on('toggle', function(control, status) {
    if(status) {
      self.depthPolygonLayer = new OpenLayers.Layer.Vector("Filtro de mapa de profundidad");
      self.map.addLayer(self.depthPolygonLayer);
      self.depthPolygonControl = new OpenLayers.Control.DrawFeature(self.depthPolygonLayer, OpenLayers.Handler.Polygon, {
        featureAdded: function(vector) {
          self.showDepthWindow(vector);
        }
      });
      self.map.addControl(self.depthPolygonControl);
      self.depthPolygonControl.activate();
    } else {
      self.stopDepthSelection();
    }
  });
  
  var allFields = parametersPanel.findByType(Ext.form.Field);
  applyButton.on('click', function() {
    self.mapData.zoom = zoomControl.getValue();
    self.mapData.centerLatitude = centerLatitudeControl.getValue();
    self.mapData.centerLongitude = centerLongitudeControl.getValue();
    self.mapData.styleId = styleControl.getValue();
    var errors = false;
    Ext.each(allFields, function(field) {
      errors = errors || !field.isValid();
    });
    if (errors) {
      Ext.Msg.alert('Aplicar', 'Por favor, corrija primero los errores.');
      return;
    }
    if (minDateTypeNoneControl.getValue()) {
      self.mapData.minDateType = 'NONE';
    } else if (minDateTypeRelativeControl.getValue()) {
      self.mapData.minDateType = 'RELATIVE';
    } else if (minDateTypeAbsoluteControl.getValue()) {
      self.mapData.minDateType = 'ABSOLUTE';
    }
    self.mapData.minDateRelativeAmount = minDateRelativeAmountControl
        .getValue();
    self.mapData.minDateRelativeUnits = minDateRelativeUnitsControl
        .getValue();
    self.mapData.minDate = parseDateTime(minDateControl.getValue(),
        minTimeControl.getValue());
    if (maxDateTypeNoneControl.getValue()) {
      self.mapData.maxDateType = 'NONE';
    } else if (maxDateTypeRelativeControl.getValue()) {
      self.mapData.maxDateType = 'RELATIVE';
    } else if (maxDateTypeAbsoluteControl.getValue()) {
      self.mapData.maxDateType = 'ABSOLUTE';
    }
    self.mapData.maxDateRelativeAmount = maxDateRelativeAmountControl
        .getValue();
    self.mapData.maxDateRelativeUnits = maxDateRelativeUnitsControl
        .getValue();
    self.mapData.maxDate = parseDateTime(maxDateControl.getValue(),
        maxTimeControl.getValue());
    if (maxDepthTypeNoneControl.getValue()) {
      self.mapData.maxDepthType = 'NONE';
    } else if (maxDepthTypeAbsoluteControl.getValue()) {
      self.mapData.maxDepthType = 'ABSOLUTE';
    }
    self.mapData.maxDepth = maxDepthControl.getValue();
    if (minDepthTypeNoneControl.getValue()) {
      self.mapData.minDepthType = 'NONE';
    } else if (minDepthTypeAbsoluteControl.getValue()) {
      self.mapData.minDepthType = 'ABSOLUTE';
    }
    self.mapData.minDepth = minDepthControl.getValue();
    self.mapData.magnitudeType = magnitudeTypeControl.getValue();
    if (maxMagnitudeTypeNoneControl.getValue()) {
      self.mapData.maxMagnitudeType = 'NONE';
    } else if (maxMagnitudeTypeAbsoluteControl.getValue()) {
      self.mapData.maxMagnitudeType = 'ABSOLUTE';
    }
    self.mapData.maxMagnitude = maxMagnitudeControl.getValue();
    if (minMagnitudeTypeNoneControl.getValue()) {
      self.mapData.minMagnitudeType = 'NONE';
    } else if (minMagnitudeTypeAbsoluteControl.getValue()) {
      self.mapData.minMagnitudeType = 'ABSOLUTE';
    }

    self.mapData.minMagnitude = minMagnitudeControl.getValue();
    self.mapData.listUnmeasured = listUnmeasuredControl.getValue();
    if (animationTypeNoneControl.getValue()) {
      self.mapData.animationType = 'NONE';
    } else if (animationTypeDateControl.getValue()) {
      self.mapData.animationType = 'DATE';
    } else if (animationTypeDepthControl.getValue()) {
      self.mapData.animationType = 'DEPTH';
    } else if (animationTypeMagnitudeControl.getValue()) {
      self.mapData.animationType = 'MAGNITUDE';
    }
    self.mapData.animationSteps = animationStepsControl.getValue();
    self.mapData.animationStepDuration = animationStepDurationControl
        .getValue();
    self.mapData.animationStepKeep = animationStepKeepControl.getValue();
    self.mapData.reverseAnimation = reverseAnimationControl.getValue();

    self.modified = true;
    if (self.mapData.id) {
      saveChangesButton.enable();
    }
    discardChangesButton.enable();
    self.loadLayers();
  });
  mapViewPanel.setTitle('Mapa: ' + self.mapData.name);

  saveChangesButton.on('click', function() {
    var mapData = self.clone(self.mapData);
    delete mapData['id'];
    var request = {
      mapId: self.mapData.id,
      map: mapData
    };
    Ext.Ajax.request({
      url: seismap.constants.baseUri + '/action/map/modify',
      method: 'POST',
      jsonData: request,
      success: function(response, opts) {
        var response = Ext.decode(response.responseText);
        if(response.exception) {
          Ext.Msg.alert('Guardar', response.exception.message);
        } else {
          saveChangesButton.disable();
          discardChangesButton.disable();
          mapViewPanel.setTitle('Mapa: ' + self.mapData.name);
          self.originalMapData = seismap.ui.clone(self.mapData);
        }
      },
      failure: function(response, opts) {
        Ext.Msg.alert('Guardar', 'Uy.. hubo un error!');
      }
   });
  });

  discardChangesButton.on('click', function() {
    saveChangesButton.disable();
    discardChangesButton.disable();
    self.mapData = seismap.ui.clone(self.originalMapData);
    self.initParameters();
    self.loadLayers();
  });

  saveMapAsButton.on('click', function() {
    Ext.Msg.prompt('Guardar como', 'Enter the new map name', function (button, mapName) {
      if (mapName == null) {
        return;
      }
      var mapData = self.clone(self.mapData);
      delete mapData['id'];
      mapData.name = mapName;
      var request = {
        userId: seismap.constants.user.id,
        map: mapData
      };
      Ext.Ajax.request({
        url: seismap.constants.baseUri + '/action/map/create',
        method: 'POST',
        jsonData: request,
        success: function(response, opts) {
          var response = Ext.decode(response.responseText);
          if(response.exception) {
            Ext.Msg.alert('Guardar como', response.exception.message);
          } else {
            self.mapData = response.value;
            mapViewPanel.setTitle('Mapa: ' + self.mapData.name);
            saveChangesButton.disable();
            discardChangesButton.disable();
            deleteMapButton.enable();
            self.originalMapData = seismap.ui.clone(self.mapData);
          }
        },
        failure: function(response, opts) {
          Ext.Msg.alert('Guardar como', 'Uy.. hubo un error!');
        }
      });
    });
  });

  var showLegendButton = Ext.getCmp('showLegendButton');
  showLegendButton.on('toggle',  function(control, status) {
    if(status) {
      self.legendWindow.show();
    } else {
      self.legendWindow.hide();
    }
  });
  this.legendWindow.on('hide', function() {
    if (showLegendButton.pressed) {
      showLegendButton.toggle();
    }
  });
  
  var self = this;
  Ext.getCmp('mapsTree').on('click', function(node) {
    if (node.isLeaf()) {
      var request = {
        mapId: node.id
      };
      Ext.Ajax.request({
        url: seismap.constants.baseUri + '/action/map/get',
        method: 'POST',
        jsonData: request,
        success: function(response, opts) {
          var response = Ext.decode(response.responseText);
          if(response.exception) {
            Ext.Msg.alert('Abrir mapa', response.exception.message);
          } else {
            var map = response.value;
            mapViewPanel.setTitle('Mapa: ' + self.mapData.name);
            self.setMapData(map);
            self.initParameters();
            self.loadLayers();
          }
        },
        failure: function(response, opts) {
          Ext.Msg.alert('Abrir mapa', 'Uy.. hubo un error!');
        }
      });
    }
  });

};
seismap.ui.initParameters = function () {
  function formatDate(dateTimeValue) {
    var dateValue = new Date(dateTimeValue);
    dateValue.setHours(0);
    dateValue.setMinutes(0);
    return dateValue;
  }
  function formatTime(dateTimeValue) {
    var hours = dateTimeValue.getHours();
    var minutes = dateTimeValue.getMinutes();
    if (minutes > 0 && minutes < 15) {
      minutes = 0;
    } else if (minutes > 15 && minutes < 30) {
      minutes = 15;
    } else if (minutes > 30 && minutes < 45) {
      minutes = 30;
    } else if (minutes > 45 && minutes < 60) {
      minutes = 45;
    }
    var ampm = 'AM';
    if (hours > 12) {
      hours -= 12;
      ampm = 'PM';
    }
    if (hours == 0) {
      hours = 12;
    }
    var timeValue = hours + ':' + (minutes < 10 ? '0' + minutes : minutes)
        + ' ' + ampm;
    return timeValue;
  }
  var self = this;
  var zoomControl = Ext.getCmp('initialZoomControl');
  var centerLatitudeControl = Ext.getCmp('initialLatitudeControl');
  var centerLongitudeControl = Ext.getCmp('initialLongitudeControl');
  var styleControl = Ext.getCmp('styleCombo');

  var minDateTypeNoneControl = Ext.getCmp('dateMinModeNoneRadio');
  var minDateTypeRelativeControl = Ext.getCmp('dateMinModeRelativeRadio');
  var minDateTypeAbsoluteControl = Ext.getCmp('dateMinModeAbsoluteRadio');
  var minDateRelativeAmountControl = Ext.getCmp('dateMinRelativeAmountField');
  var minDateRelativeUnitsControl = Ext.getCmp('dateMinRelativeUnitsCombo');
  var minDateControl = Ext.getCmp('dateMinAbsoluteDateField');
  var minTimeControl = Ext.getCmp('dateMinAbsoluteTimeField');
  var maxDateTypeNoneControl = Ext.getCmp('dateMaxModeNoneRadio');
  var maxDateTypeRelativeControl = Ext.getCmp('dateMaxModeRelativeRadio');
  var maxDateTypeAbsoluteControl = Ext.getCmp('dateMaxModeAbsoluteRadio');
  var maxDateRelativeAmountControl = Ext.getCmp('dateMaxRelativeAmountField');
  var maxDateRelativeUnitsControl = Ext.getCmp('dateMaxRelativeUnitsCombo');
  var maxDateControl = Ext.getCmp('dateMaxAbsoluteDateField');
  var maxTimeControl = Ext.getCmp('dateMaxAbsoluteTimeField');
  var maxDepthTypeNoneControl = Ext.getCmp('depthMaxModeNoneRadio');
  var maxDepthTypeAbsoluteControl = Ext.getCmp('depthMaxModeAbsoluteRadio');
  var maxDepthControl = Ext.getCmp('depthMaxAbsoluteAmountField');
  var minDepthTypeNoneControl = Ext.getCmp('depthMinModeNoneRadio');
  var minDepthTypeAbsoluteControl = Ext.getCmp('depthMinModeAbsoluteRadio');
  var minDepthControl = Ext.getCmp('depthMinAbsoluteAmountField');
  var magnitudeTypeControl = Ext.getCmp('magnitudeScaleCombo');
  var maxMagnitudeTypeNoneControl = Ext.getCmp('magnitudeMaxModeNoneRadio');
  var maxMagnitudeTypeAbsoluteControl = Ext
      .getCmp('magnitudeMaxModeAbsoluteRadio');
  var maxMagnitudeControl = Ext.getCmp('magnitudeMaxAbsoluteAmountField');
  var minMagnitudeTypeNoneControl = Ext.getCmp('magnitudeMinModeNoneRadio');
  var minMagnitudeTypeAbsoluteControl = Ext
      .getCmp('magnitudeMinModeAbsoluteRadio');
  var minMagnitudeControl = Ext.getCmp('magnitudeMinAbsoluteAmountField');
  var listUnmeasuredControl = Ext
      .getCmp('magnitudeUnmeasuredVisibilityCheckbox');

  var animationTypeNoneControl = Ext.getCmp('animationByNoneRadio');
  var animationTypeDateControl = Ext.getCmp('animationByDateRadio');
  var animationTypeDepthControl = Ext.getCmp('animationByDepthRadio');
  var animationTypeMagnitudeControl = Ext.getCmp('animationByMagnitudeRadio');
  var animationStepsControl = Ext.getCmp('animationStepAmountField');
  var animationStepDurationControl = Ext.getCmp('animationDurationField');
  var animationStepKeepControl = Ext.getCmp('animationKeepPreviousAmountField');
  var reverseAnimationControl = Ext.getCmp('reverseAnimationCheckbox');

  var showInitialViewLink = Ext.getCmp('showInitialViewLink');
  var useCurrentViewLink = Ext.getCmp('useCurrentViewLink');
  zoomControl.setValue(self.mapData.zoom);
  centerLatitudeControl.setValue(self.mapData.centerLatitude);
  centerLongitudeControl.setValue(self.mapData.centerLongitude);
  styleControl.setValue(self.mapData.styleId);

  minDateTypeNoneControl.setValue(self.mapData.minDateType == 'NONE');
  minDateTypeRelativeControl.setValue(self.mapData.minDateType == 'RELATIVE');
  minDateTypeAbsoluteControl.setValue(self.mapData.minDateType == 'ABSOLUTE');
  minDateRelativeAmountControl.setValue(self.mapData.minDateRelativeAmount);
  minDateRelativeUnitsControl.setValue(self.mapData.minDateRelativeUnits);
  minDateControl.setValue(formatDate(self.mapData.minDate));
  minTimeControl.setValue(formatTime(self.mapData.minDate));
  maxDateTypeNoneControl.setValue(self.mapData.maxDateType == 'NONE');
  maxDateTypeRelativeControl.setValue(self.mapData.maxDateType == 'RELATIVE');
  maxDateTypeAbsoluteControl.setValue(self.mapData.maxDateType == 'ABSOLUTE');
  maxDateRelativeAmountControl.setValue(self.mapData.maxDateRelativeAmount);
  maxDateRelativeUnitsControl.setValue(self.mapData.maxDateRelativeUnits);
  maxDateControl.setValue(formatDate(self.mapData.maxDate));
  maxTimeControl.setValue(formatTime(self.mapData.maxDate));
  maxDepthTypeNoneControl.setValue(self.mapData.maxDepthType == 'NONE');
  maxDepthTypeAbsoluteControl.setValue(self.mapData.maxDepthType == 'ABSOLUTE');
  maxDepthControl.setValue(self.mapData.maxDepth);
  minDepthTypeNoneControl.setValue(self.mapData.minDepthType == 'NONE');
  minDepthTypeAbsoluteControl.setValue(self.mapData.minDepthType == 'ABSOLUTE');
  minDepthControl.setValue(self.mapData.minDepth);
  magnitudeTypeControl.setValue(self.mapData.magnitudeType);
  maxMagnitudeTypeNoneControl.setValue(self.mapData.maxMagnitudeType == 'NONE');
  maxMagnitudeTypeAbsoluteControl
      .setValue(self.mapData.maxMagnitudeType == 'ABSOLUTE');
  maxMagnitudeControl.setValue(self.mapData.maxMagnitude);
  minMagnitudeTypeNoneControl.setValue(self.mapData.minMagnitudeType == 'NONE');
  minMagnitudeTypeAbsoluteControl
      .setValue(self.mapData.minMagnitudeType == 'ABSOLUTE');
  minMagnitudeControl.setValue(self.mapData.minMagnitude);
  listUnmeasuredControl.setValue(self.mapData.listUnmeasured);

  animationTypeNoneControl.setValue(self.mapData.animationType == 'NONE');
  animationTypeDateControl.setValue(self.mapData.animationType == 'DATE');
  animationTypeDepthControl.setValue(self.mapData.animationType == 'DEPTH');
  animationTypeMagnitudeControl
      .setValue(self.mapData.animationType == 'MAGNITUDE');
  animationStepsControl.setValue(self.mapData.animationSteps);
  animationStepDurationControl.setValue(self.mapData.animationStepDuration);
  animationStepKeepControl.setValue(self.mapData.animationStepKeep);
  reverseAnimationControl.setValue(self.mapData.reverseAnimation);
};
seismap.ui.initEventParameters = function () {
  function formatDate(dateTimeValue) {
    var dateValue = new Date(dateTimeValue);
    dateValue.setHours(0);
    dateValue.setMinutes(0);
    return dateValue;
  }
  function formatTime(dateTimeValue) {
    var hours = dateTimeValue.getHours();
    var minutes = dateTimeValue.getMinutes();
    var ampm = 'AM';
    if (hours > 12) {
      hours -= 12;
      ampm = 'PM';
    }
    if (hours == 0) {
      hours = 12;
    }
    var timeValue = hours + ':' + (minutes < 10 ? '0' + minutes : minutes)
        + ' ' + ampm;
    return timeValue;
  }
  var self = this;
  var nameControl = Ext.getCmp('eventNameField');
  var dateControl = Ext.getCmp('eventDateDateField');
  var timeControl = Ext.getCmp('eventDateTimeField');
  var referenceControl = Ext.getCmp('eventReferenceField');
  var magnitudeControl = Ext.getCmp('eventMagnitudeField');
  var rankMagnitudeControl = Ext.getCmp('eventRankMagnitudeField');
  var depthControl = Ext.getCmp('eventDepthField');
  var notesControl = Ext.getCmp('eventNotesArea');
  var perceivedDistanceControl = Ext.getCmp('eventPerceivedDistanceField');
  var damagedDistanceControl = Ext.getCmp('eventDamagedDistanceField');
  
  nameControl.setValue(self.eventData.name);
  dateControl.setValue(formatDate(self.eventData.date));
  timeControl.setValue(formatTime(self.eventData.date));
  referenceControl.setValue(self.eventData.reference);
  magnitudeControl.setValue(self.eventData[self.mapData.magnitudeType + 'Magnitude']);
  rankMagnitudeControl.setValue(self.eventData.RANKMagnitude);
  notesControl.setValue(self.eventData.notes);
  depthControl.setValue(self.eventData.depth);
  perceivedDistanceControl.setValue(self.eventData.perceivedDistance == null ? null : self.eventData.perceivedDistance / 1000);
  damagedDistanceControl.setValue(self.eventData.damagedDistance == null ? null : self.eventData.damagedDistance / 1000);
  
  var magnitudesData = [];
  for (var i=0; i<self.eventData.magnitudes.length; i++) {
    var magnitude = self.eventData.magnitudes[i];
    var typeName = null;
    for (var j=0; j<seismap.constants.magnitudeTypes.length; j++) {
      var type = seismap.constants.magnitudeTypes[j];
      if (type.id == magnitude.type) {
        typeName = type.name;
        break;
      }
    }
    magnitudesData.push({
      id: magnitude.id,
      agency: magnitude.reportingAgency.code,
      value: magnitude.value,
      type: typeName
    });
  }
  var eventMagnitudeStore = Ext.StoreMgr.get('eventMagnitudeStore');
  eventMagnitudeStore.loadData(magnitudesData);
};
seismap.ui.buildEventInformation = function (id, name, reference, date, notes) {
  var information = name;
  if (information == null || information.length == 0) {
    if (reference != null && reference.length > 0) {
      information = reference + ' '+ date.format('d/m/Y h:i a');
    }
  }
  if (information == null || information.length == 0) {
    if (notes != null && notes.length > 0) {
      information = date.format('d/m/Y h:i a') + ' ' + notes;
    }
  }
  if (information == null || information.length == 0) {
    if (date != null) {
      information = 'Sismo ' + id + ' del ' + date.format('d/m/Y h:i a');
    }
  }
  if (information == null || information.length == 0) {
    information = 'Sismo ' + id;
  }
  return information;
}
seismap.ui.initMap = function() {
  this.minWait = -1;

  OpenLayers.ImgPath = seismap.constants.baseUri
      + "/resources/css/lib/openlayers/img/"

  var options = {
    controls : [],
    numZoomLevels : 22,
    units : 'degrees',
    displayProjection : new OpenLayers.Projection('EPSG:4326'),
    theme : seismap.constants.baseUri
        + "/resources/css/lib/openlayers/theme/default/style.css"
  };
  this.map = new OpenLayers.Map(options);
  this.map.addControl(new OpenLayers.Control.PanZoomBar({
    position : new OpenLayers.Pixel(2, 15)
  }));
  this.map.addControl(new OpenLayers.Control.Navigation());
  this.map.addControl(new OpenLayers.Control.LayerSwitcher({'div':OpenLayers.Util.getElement('layerswitcher')}));
  this.map.addControl(new OpenLayers.Control.ScaleLine());
  this.registerGetFeaturesControl(this.map, this.getFeatures);
  
  var mapArea = Ext.getCmp('mapArea');

  var center = new OpenLayers.LonLat(this.mapData.centerLongitude,
      this.mapData.centerLatitude);
  var zoom = this.mapData.zoom;

  this.mapPanel = new GeoExt.MapPanel({
    renderTo : "mapArea",
    stateId : "mapArea",
    height : mapArea.getSize().height,
    width : mapArea.getSize().width,
    center : center,
    zoom : zoom,
    map : this.map
  });

  var gphy = new OpenLayers.Layer.Google("Google Physical", {
    type : google.maps.MapTypeId.TERRAIN,
  });
  var gmap = new OpenLayers.Layer.Google("Google Streets", // the default
  {
    numZoomLevels : 20
  });
  var ghyb = new OpenLayers.Layer.Google("Google Hybrid", {
    type : google.maps.MapTypeId.HYBRID,
    numZoomLevels : 20
  });
  var gsat = new OpenLayers.Layer.Google("Google Satellite", {
    type : google.maps.MapTypeId.SATELLITE,
    numZoomLevels : 22
  });
  this.map.addLayers([ gphy, gmap, ghyb, gsat ]);
  
  center = center.transform(this.map.displayProjection, this.map.getProjectionObject());
  this.map.setCenter(center, zoom);

  var self = this;
  mapArea.on('resize', function(mapArea) {
    self.mapPanel.setSize(mapArea.getSize());
  });
  // this.map.setCenter(new OpenLayers.LonLat(this.mapData.centerLongitude,
  // this.mapData.centerLatitude), this.mapData.zoom);

  // build up all controls
  // this.map.addControl(new OpenLayers.Control.Scale(document.id('scale')));
  // this.map.addControl(new OpenLayers.Control.MousePosition({
  // element : document.id('location')
  // }));
  this.currentFrame = -1
  this.loadLayers();

};
seismap.ui.registerGetFeaturesControl = function (map, infoFunction) {
  map.addControl(new OpenLayers.Control.WMSGetFeatureInfo({
      id: 'featureInfo',
      autoActivate: true,
      drillDown: true,
      infoFormat: "application/vnd.ogc.gml",
      maxFeatures: 1000,
      eventListeners: {
          "getfeatureinfo": infoFunction
      }
    }));
};
seismap.ui.getFeatures = function(e) {
  var self = seismap.ui;
  var data = [];
  Ext.each(e.features, function(feature) {
    var attributes = feature.attributes;
    var id;
    if (attributes.id == undefined) {
      var fid = feature.fid;
      id = fid.substring(fid.indexOf('.') + 1);
    } else {
      id = parseInt(attributes.id);
    }
     attributes.id == undefined ? feature.id : parseInt(attributes.id);
    var date = new Date(attributes.date);
    var information = self.buildEventInformation(id, 
        attributes.name, attributes.reference, date, attributes.notes);
    var event = {
        id: id,
        information: information,
        date : date
    };
    if (attributes.magnitude != undefined) {
      event.magnitude = parseFloat(attributes.magnitude);
    }
    if (attributes.rankmagnitude != undefined) {
      event.rankmagnitude = parseFloat(attributes.rankmagnitude);
    }
    data.push(event);
  });
  var locationEventStore = Ext.StoreMgr.get('locationEventStore');
  locationEventStore.loadData(data);
  if (data.length == 0) {
    // ignore
  } else if (data.length == 1) {
    self.showEventWindow(data[0].id, data[0].information);
  } else { 
    var locationEventsWindow = Ext.WindowMgr.get('locationEventsWindow');
    locationEventsWindow.show();
    self.legendWindow.toFront();
  }
};
seismap.ui.loadLayers = function() {
  document.title = (isNaN(parseInt(document.title)) ? 0
      : parseInt(document.title)) + 1;
  this.stop();
  if (this.currentFrame != -1) {
    this.removeLayer(this.layers[this.currentFrame]);
    for ( var i = 0; i < this.layers.length; i++) {
      var layer = this.layers[i];
      this.map.removeLayer(layer);
    }
  }
  this.updateLegendWindow();
  this.cqlFilters = this.buildCqlFilters(this.mapData,
      seismap.constants.dataBounds, new Date());
  this.layers = [];
  for ( var i = 0; i < this.cqlFilters.length; i++) {
    var cqlFilter = this.cqlFilters[i];
    // document.id('mapUris').value += cqlFilter + '\n';
    var layerName = this.cqlFilters.length == 1 ? 'Sismos' : 'Sismos - Cuadro ' + (i + 1); 
    this.layers[i] = this.createLayer(this.map, null, cqlFilter, layerName, false, null);
  }
  this.currentFrame = -1;
  this.start();
};
seismap.ui.updateLegendWindow = function () {
  var style;
  for ( var i = 0; i < seismap.constants.styles.length; i++) {
    var aStyle = seismap.constants.styles[i];
    if (aStyle.id == this.mapData.styleId) {
      style = aStyle;
      break;
    }
  }
  var url = seismap.constants.baseUri + 'legend/' + style.sld;
  Ext.getCmp('legendImage').getEl().setStyle('background-image', 'url(' + url + ')');
};
seismap.ui.start = function() {
  this.cycle();
  if (this.layers.length > 1) {
    this.animationHandle = setInterval(this.cycle.bind(this),
        this.mapData.animationStepDuration * 1000);
  }
}, seismap.ui.stop = function() {
  if (this.animationHandle) {
    clearInterval(this.animationHandle);
    this.animationHandle = null;
  }
};
seismap.ui.nextFrame = function() {
  this.cycle();
  if (this.animationHandle) {
    clearInterval(this.animationHandle);
    this.animationHandle = setInterval(this.cycle.bind(this),
        this.mapData.animationStepDuration * 1000);
  }
};
seismap.ui.previousFrame = function() {
  this.cycle(true);
  if (this.animationHandle) {
    clearInterval(this.animationHandle);
    this.animationHandle = setInterval(this.cycle.bind(this),
        this.mapData.animationStepDuration * 1000);
  }
};
seismap.ui.cycle = function(backwards) {
  var current = this.currentFrame;
  if (current != -1) {
    this.removeLayer(this.layers[current]);
  }
  if (backwards == true) {
    current--;
    if (current == -1) {
      current = this.layers.length - 1;
    }
  } else {
    current++;
    if (current == this.layers.length) {
      current = 0;
    }

  }
  this.currentFrame = current;
  this.addLayer(this.layers[current]);
};
seismap.ui.addLayer = function(layer) {
  layer.seismapAdded = new Date().getTime();
  var timeSinceRemoved = layer.seismapAdded - layer.seismapRemoved;
  var waitTime = this.minWait - timeSinceRemoved;
  if (waitTime <= 0) {
    this.doAddLayer(layer);
  } else {
    setTimeout(this.doAddLayer.bind(this, layer), waitTime);
  }
};
seismap.ui.doAddLayer = function(layer) {
  if (layer.seismapAdded > layer.seismapRemoved) {
    layer.seismapAdded = new Date().getTime();
    if (!layer.getVisibility()) {
      layer.setVisibility(true);
    }
  }
};
seismap.ui.removeLayer = function(layer) {
  layer.seismapRemoved = new Date().getTime();
  var timeSinceAdded = layer.seismapRemoved - layer.seismapAdded;
  var waitTime = this.minWait - timeSinceAdded;
  if (waitTime <= 0) {
    this.doRemoveLayer(layer);
  } else {
    setTimeout(this.doRemoveLayer.bind(this, layer), waitTime);
  }
}, seismap.ui.doRemoveLayer = function(layer) {
  if (layer.seismapRemoved > layer.seismapAdded) {
    layer.seismapRemoved = new Date().getTime();
    if (layer.getVisibility()) {
      layer.setVisibility(false);
    }
  }
};
seismap.ui.createLayer = function(map, layerRef, cqlFilter, layerName, baseLayer, style) {
  if (style == null) {
    for ( var i = 0; i < seismap.constants.styles.length; i++) {
      var aStyle = seismap.constants.styles[i];
      if (aStyle.id == this.mapData.styleId) {
        style = aStyle;
        break;
      }
    }
  }
  var params = '';
  params += '?nocache=' + new Date().getTime();
  params += '&viewparams=';
  params += 'magnitudeType:' + this.mapData.magnitudeType.toLowerCase();
  params += '&env=';
  params += 'map.magnitudeType:' + this.mapData.magnitudeType;
  for ( var name in style.variables) {
    var value = style.variables[name];
    params += ';var.' + escape(name) + ':' + escape(value);
  }
  if (cqlFilter != null) {
    params += '&CQL_FILTER=' + escape(cqlFilter);
  }
  var layer = new OpenLayers.Layer.WMS(
      layerName,
      seismap.constants.layerServerUri + '/wms' + params,
      {
        width : '1679',
        srs : 'EPSG:4326',
        layers : layerRef == null? seismap.constants.layerName : layerRef,
        height : '330',
        styles : style.sld,
        format : 'image/png',
        // cql_filter : cqlFilter,
        tiled : true,
        feature_count : 1,
        tilesOrigin : map.maxExtent.left + ',' + map.maxExtent.bottom,
        transparent : true
      }, {
        buffer : 0,
        displayOutsideMaxExtent : true,
        isBaseLayer: baseLayer
      });
  layer.setVisibility(false);
  layer.seismapAdded = -1;
  layer.seismapRemoved = new Date().getTime() - 1;
  map.addLayer(layer);
  return layer;
};
seismap.ui.buildCqlDate = function(date) {
  return '' + date.getFullYear() + '-'
      + this.twoDigitsNumber(date.getMonth() + 1) + '-'
      + this.twoDigitsNumber(date.getDate()) + 'T'
      + this.twoDigitsNumber(date.getHours()) + ':'
      + this.twoDigitsNumber(date.getMinutes()) + ':'
      + this.twoDigitsNumber(date.getSeconds()) + 'Z';
};
seismap.ui.buildCqlDateFilter = function(map, limit, operator, limitType,
    effectiveLimits, windowLimit) {
  if (limitType == 'ABSOLUTE' || limitType == 'RELATIVE'
      || map.animationType == 'DATE') {
    if (map.animationType == 'DATE') {
      var limitTimestamp = windowLimit
          * (effectiveLimits.maxDate.getTime() - effectiveLimits.minDate
              .getTime()) + effectiveLimits.minDate.getTime();
      limit = new Date(limitTimestamp);
    }
    var filter = 'date ' + operator + ' ' + this.buildCqlDate(limit);
    return filter;
  } else {
    // no filter
    return null;
  }
};
seismap.ui.buildCqlDepthFilter = function(map, limit, operator, limitType,
    effectiveLimits, windowLimit) {
  if (limitType == 'ABSOLUTE' || map.animationType == 'DEPTH') {
    if (map.animationType == 'DEPTH') {
      limit = windowLimit
          * (effectiveLimits.maxDepth - effectiveLimits.minDepth)
          + effectiveLimits.minDepth;
    }
    var filter = 'depth ' + operator + ' ' + limit;
    return filter;
  } else {
    // no filter
    return null;
  }
};
seismap.ui.buildCqlMagnitudeFilter = function(map, limit, operator, limitType,
    effectiveLimits, windowLimit) {
  if (limitType == 'ABSOLUTE' || map.animationType == 'MAGNITUDE') {
    if (map.animationType == 'MAGNITUDE') {
      limit = windowLimit
          * (effectiveLimits.maxMagnitude - effectiveLimits.minMagnitude)
          + effectiveLimits.minMagnitude;
    }
    var filter = 'magnitude ' + operator + ' ' + limit;
    if (map.listUnmeasured) {
      filter = '(magnitude IS NULL OR ' + filter + ')';
    }
    return filter;
  } else {
    if (!map.listUnmeasured) {
      var filter = 'magnitude IS NOT NULL';
      return filter;
    } else {
      // no filter
      return null;
    }
  }
};
seismap.ui.concatenateCqlFilter = function(soFar, added) {
  if (!soFar) {
    return added;
  } else if (!added) {
    return soFar;
  } else {
    return soFar + ' AND ' + added;
  }
};
seismap.ui.buildCqlFilter = function(map, effectiveLimits, windowStart,
    windowEnd) {
  var filter = null;
  var minDateFilter = this.buildCqlDateFilter(map, effectiveLimits.minDate,
      'AFTER', map.minDateType, effectiveLimits, windowStart);
  filter = this.concatenateCqlFilter(filter, minDateFilter);
  var maxDateFilter = this.buildCqlDateFilter(map, effectiveLimits.maxDate,
      'BEFORE', map.maxDateType, effectiveLimits, windowEnd);
  filter = this.concatenateCqlFilter(filter, maxDateFilter);
  var minDepthFilter = this.buildCqlDepthFilter(map, effectiveLimits.minDepth,
      '>=', map.minDepthType, effectiveLimits, windowStart);
  filter = this.concatenateCqlFilter(filter, minDepthFilter);
  var maxDepthFilter = this.buildCqlDepthFilter(map, effectiveLimits.maxDepth,
      '<=', map.maxDepthType, effectiveLimits, windowEnd);
  filter = this.concatenateCqlFilter(filter, maxDepthFilter);
  var minMagnitudeFilter = this.buildCqlMagnitudeFilter(map,
      effectiveLimits.minMagnitude, '>=', map.minMagnitudeType, effectiveLimits,
      windowStart);
  filter = this.concatenateCqlFilter(filter, minMagnitudeFilter);
  var maxMagnitudeFilter = this.buildCqlMagnitudeFilter(map, map.maxMagnitude,
      '<=', map.maxMagnitudeType, effectiveLimits, windowEnd);
  filter = this.concatenateCqlFilter(filter, maxMagnitudeFilter);
  return filter;
};
seismap.ui.buildStaticCqlFilter = function(map, dataBounds, currentDate) {
  var effectiveLimits = this.getEffectiveLimits(map, dataBounds, currentDate);
  var filter = this.buildCqlFilter(map, effectiveLimits, 0, 1);
  return filter;
};
seismap.ui.buildCqlFilters = function(map, dataBounds, currentDate) {
  if (map.animationType == 'NONE') {
    var filter = this.buildStaticCqlFilter(map, dataBounds, currentDate);
    return [ filter ];
  }
  var effectiveLimits = this.getEffectiveLimits(map, dataBounds, currentDate);
  var steps = map.animationSteps;
  var delta;
  var windowStart;
  var windowEnd;
  if (map.reverseAnimation) {
    delta = -1 / steps;
    windowStart = 1 + delta;
    windowEnd = 1 - delta * map.animationStepKeep;
  } else {
    delta = 1 / steps;
    windowStart = -delta * map.animationStepKeep;
    windowEnd = delta;
  }
  var filters = [];
  for ( var i = 0; i < steps; i++) {
    var filter = this.buildCqlFilter(map, effectiveLimits, Math.max(0,
        windowStart), Math.min(1, windowEnd));
    filters[i] = filter;
    windowStart += delta;
    windowEnd += delta;
  }
  return filters;
};
seismap.ui.getEffectiveDate = function(boundDate, currentDate, limitType,
    fixedDate, relativeAmount, relativeUnits) {
  if (limitType == 'ABSOLUTE') {
    return fixedDate;
  } else if (limitType == 'RELATIVE') {
    var limit = new Date(currentDate.getFullYear(), currentDate.getMonth(),
        currentDate.getDate(), currentDate.getHours(),
        currentDate.getMinutes(), currentDate.getSeconds(), currentDate
            .getMilliseconds());
    if (relativeUnits == 'MINUTE') {
      limit.setMinutes(limit.getMinutes() - relativeAmount);
    } else if (relativeUnits == 'HOUR') {
      limit.setHours(limit.getHours() - relativeAmount);
    } else if (relativeUnits == 'DAY') {
      limit.setDate(limit.getDate() - relativeAmount);
    } else if (relativeUnits == 'WEEK') {
      limit.setDate(limit.getDate() - relativeAmount * 7);
    } else if (relativeUnits == 'MONTH') {
      limit.setMonth(limit.getMonth() - relativeAmount);
    } else if (relativeUnits == 'YEAR') {
      limit.setFullYear(limit.getFullYear() - relativeAmount);
    } else {
      return null;
    }
    return limit;
  } else /* if (limitType == 'NONE') */{
    return boundDate;
  }
};
seismap.ui.getEffectiveDepth = function(boundDepth, limitType, fixedDepth) {
  if (limitType == 'ABSOLUTE') {
    return fixedDepth;
  } else /* if (limitType == 'NONE') */{
    return boundDepth;
  }
};
seismap.ui.getEffectiveMagnitude = function(boundMagnitude, limitType,
    fixedMagnitude) {
  if (limitType == 'ABSOLUTE') {
    return fixedMagnitude;
  } else /* if (limitType == 'NONE') */{
    return boundMagnitude;
  }
};
seismap.ui.getEffectiveLimits = function(map, dataBounds, currentDate) {
  var effectiveLimits = {};
  effectiveLimits.minDate = this.getEffectiveDate(dataBounds.minDate,
      currentDate, map.minDateType, map.minDate, map.minDateRelativeAmount,
      map.minDateRelativeUnits);
  effectiveLimits.maxDate = this.getEffectiveDate(dataBounds.maxDate,
      currentDate, map.maxDateType, map.maxDate, map.maxDateRelativeAmount,
      map.maxDateRelativeUnits);
  effectiveLimits.minDepth = this.getEffectiveDepth(dataBounds.minDepth,
      map.minDepthType, map.minDepth);
  effectiveLimits.maxDepth = this.getEffectiveDepth(dataBounds.maxDepth,
      map.maxDepthType, map.maxDepth);
  var magnitudeBounds = dataBounds.magnitudeBounds[map.magnitudeType];
  effectiveLimits.minMagnitude = this.getEffectiveMagnitude(
      magnitudeBounds.min, map.minMagnitudeType, map.minMagnitude);
  effectiveLimits.maxMagnitude = this.getEffectiveMagnitude(
      magnitudeBounds.max, map.maxMagnitudeType, map.maxMagnitude);
  return effectiveLimits;
};
seismap.ui.twoDigitsNumber = function(number) {
  if (number < 10) {
    return '0' + number;
  } else {
    return '' + number;
  }
};
seismap.ui.setMapData = function(mapData) {
  this.mapData = mapData;
  if (this.mapData.minDate) {
    this.mapData.minDate = new Date(this.mapData.minDate);
  }
  if (this.mapData.maxDate) {
    this.mapData.maxDate = new Date(this.mapData.maxDate);
  }
  this.originalMapData = seismap.ui.clone(this.mapData);
};